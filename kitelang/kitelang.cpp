
#include "kitelang.h"
#include <filesystem>

static std::string nthln(const std::string& str, int n) {
	std::istringstream stream(str);
	std::string line;
	int lineNumber = 0;

	while (std::getline(stream, line)) {
		++lineNumber;
		if (lineNumber == n) {
			for (char& ch : line)
				if (ch == '\t')
					ch = ' ';
			return line;
		}
	}

	return "";
}

static void printerr(errors::kiterr e, std::string sender, std::string src) {
	std::string ln = std::to_string(e.line) + ": ";
	std::cerr << "kite: " << sender << ": " << e.what() << " at line " << e.line << std::endl << std::endl;
	std::cerr << ln << nthln(src, e.line) << std::endl;
	for (int i = 1; i < e.pos_start + ln.size(); i++) std::cerr << ' ';
	for (int i = 0; i < e.pos_end - e.pos_start; i++) std::cerr << '^';
	if (e.pos_end == e.pos_start) std::cerr << '^';
	std::cerr << " HERE" << std::endl;
}

int main(int argc, char* argv[]) {
	// if the count of the arguments is not 2, then the syntax is incorrect, print usage and exit
	if (argc != 2) {
		std::cerr << "kite: usage: kite (path/to/source.kite)" << std::endl;
		return 1;
	}

	std::ifstream file(argv[1]);
	std::string src;

	std::filesystem::path path(argv[1]);

	// exit if file failed to open
	if (!file.is_open() || !file) {
		std::cerr << "kite: failed to open file" << std::endl;
		return 1;
	}

	std::filesystem::current_path(path.parent_path());

	// read the file into src
	std::ostringstream ss;
	ss << file.rdbuf();
	src = ss.str();

	// Precompilation section
	try {
		Precompiler pc;
		src = pc.precompile(src);
	}
	catch (std::runtime_error e) {
		std::cerr << "kite: precompiler: " << e.what() << std::endl;
		return 1;
	}

	// Debugging code to show the modified source
	// std::cout << src;

	std::vector<token_ptr> tokens;

	// Tokenization section
	try {
		lexer::Lexer lex(src);
		tokens = lex.tokenize();
	}
	catch (errors::kiterr e) {
		printerr(e, "lexer", src);
		return 1;
	}

	// Debugging code for printing the tokens generated by the lexer
	// for (int i = 0; i < tokens.size(); i++) {
	//		std::cout << i << ": TOKEN(" << tokens[i]->type << ", " << tokens[i]->value << ", " << tokens[i]->value_str << ")" << std::endl;
	// }

	// Parsing section
	std::shared_ptr<parser::RootNode> root;
	parser::Parser parser(tokens);
	try {
		// Try parsing and get the reference to the root node in `root`
		root = parser.parse();
	}
	catch (errors::kiterr e) {
		printerr(e, "parser", src);
		return 1;
	}

	// Debugging line for printing the syntax tree
	// root->print(0);

	compiler::Compiler compiler(root);
	try {
		// start code generation
		compiler.codegen();
	}
	catch (errors::kiterr e) {
		printerr(e, "compiler", src);
		return 1;
	}
	
	// print the result to file stream
	system("mkdir kbuild");
	std::ofstream outFile("kbuild/" + path.filename().replace_extension().string() + ".asm", std::ios::trunc);
	if (!outFile) {
		std::cerr << "Error opening file for writing." << std::endl;
		return 1;
	}
	compiler.print(outFile);
	outFile.close();

	std::string projname = path.filename().replace_extension().string();
	std::string stdlibobjs = "stdlib/obj/*.o";

	// build executable (NASM and LD required)

	// build to object file (NASM required)
	std::cout << "nasm -felf64 -o kbuild/" + projname + ".o kbuild/" + projname + ".asm\n";

	// comment out if running linux with nasm and ld
	// system(("nasm -felf64 -o kbuild/" + projname + ".o kbuild/" + projname + ".asm").c_str());

	// link with stdlibs
	std::cout << "ld -o kbuild/" + projname + " kbuild/" + projname + ".o " + stdlibobjs << std::endl;
	// comment out if running linux with nasm and ld
	// system(("ld -o kbuild/" + projname + " kbuild/" + projname + ".o " + stdlibobjs).c_str());

	return 0;
}
