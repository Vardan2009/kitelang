
#include "kitelang.h"

int main(int argc, char* argv[]) {
	// if the count of the arguments is not 2, then the syntax is incorrect, print usage and exit
	if (argc != 2) {
		std::cerr << "kite: usage: kite (path/to/file.kite)" << std::endl;
		return 1;
	}

	std::ifstream file(argv[1]);
	std::string src;

	// exit if file failed to open
	if (!file.is_open() || !file) {
		std::cerr << "kite: failed to open file" << std::endl;
		return 1;
	}

	// read the file into src
	std::ostringstream ss;
	ss << file.rdbuf();
	src = ss.str();

	std::vector<token_ptr> tokens;

	// Tokenization section
	try {
		lexer::Lexer lex(src);
		tokens = lex.tokenize();
	}
	catch (std::runtime_error e) {
		std::cerr << "kite: lexer: " << e.what() << std::endl;
		exit(1);
	}

	// Debugging code for printing the tokens generated by the lexer
	// for (int i = 0; i < tokens.size(); i++) {
	//		std::cout << i << ": TOKEN(" << tokens[i]->type << ", " << tokens[i]->value << ", " << tokens[i]->value_str << ")" << std::endl;
	// }

	// Parsing section
	std::shared_ptr<parser::RootNode> root;
	parser::Parser parser(tokens);
	try {
		// Try parsing and get the reference to the root node in `root`
		root = parser.parse();
	} catch (std::runtime_error e) {
		std::cerr << "kite: parser: " << e.what() << " at token index " << parser.ptr << std::endl;
		return 1;
	}

	// Debugging line for printing the syntax tree
	// root->print(0);

	compiler::Compiler compiler(root);
	try {
		// start code generation
		compiler.codegen();
	} catch (std::runtime_error e) {
		std::cerr << "kite: compiler: " << e.what() << std::endl;
		return 1;
	}
	
	// print the result to cout stream
	compiler.print(std::cout);

	return 0;
}
