global _start

% TYPES!!!!
fn _start() : byte {
    let stra : char[20]
    readln(stra, 20)
    let strb : char[20]
    readln(strb, 20)
    let oper : char = '\0'
    oper = readc()

    let a : int64 = stoi(stra)
    let b : int64 = stoi(stra)

    if oper == '+' {
        printi(a + b)
        return 0
    }
    if oper == '-' {
        printi(a - b)
        return 0
    }
    if oper == '*' {
        printi(a * b)
        return 0
    }
    if oper == '/' {
        printi(a / b)
        return 0
    }
    if oper == '^' {
        printi(pow(a, b))
        return 0
    }

    print("invalid operation, try +-*/^")
    return 1
}

~
==========================
STANDARD LIBRARY FUNCTIONS
==========================
~

~
print function
args:
    the pointer to the string (stored in rdi)
usage example:
    print("Hello World!")
returns:
    none
~
fn print(str : ptr8) : void {
    asm "push rdi"                      % preserve the pointer to the string on the stack
    asm "mov rax, 1"                    % RAX - syscall id for write
    asm "mov rdi, 1"                    % RDI - file descriptor (STDOUT)
    asm ".kprint_loop:"                 % start of the printing loop
    asm "    mov rsi, [rsp]"            % load the pointer to the string from the stack
    asm "    movzx rdx, byte [rsi]"     % load the current character into RDX
    asm "    test rdx, rdx"             % check if the character is 0 (null-terminator)
    asm "    jz .kprint_done"           % if it is 0, jump to the end of the loop
    asm "    mov rax, 1"                % prepare for syscall again
    asm "    mov rdi, 1"                % (redundant (?)) RDI - STDOUT
    asm "    mov rdx, 1"                % set the number of bytes to write (1)
    asm "    syscall"                   % invoke the syscall to write the character
    asm "    inc rsi"                   % move to the next character in the string
    asm "    mov [rsp], rsi"            % update the pointer on the stack for the next iteration
    asm "    jmp .kprint_loop"          % repeat the loop for the next character
    asm ".kprint_done:"                 % end of the printing loop
    asm "    pop rdi"                   % restore the original value of RDI
}

~
printc function
args:
    the character (stored in rdi)
usage example:
    printc('A') % prints A
returns:
    none
~
fn printc(int : char) : void {
    asm "push rdi"                    % preserve the original RDI value
    asm "mov rax, 1"                  % syscall id for write
    asm "mov rdi, 1"                  % file descriptor (STDOUT)
    asm "lea rsi, [rsp]"              % load the address of the character from the stack
    asm "mov rdx, 1"                  % number of bytes to write (1)
    asm "syscall"                     % invoke the syscall to print the character
    asm "pop rdi"                     % restore the original RDI value
}

~
printi function
args:
    the integer (stored in rdi)
usage example:
    printi(10) % prints 10
returns:
    none
~
fn printi(int : int64) : void {
    asm "mov rbp, 0"                  % initialize a counter for digits
    asm ".convert_loop:"               % start of the conversion loop
    asm "mov rax, rdi"                 % move the integer to RAX for division
    asm "mov rbx, 10"                 % divisor (base 10)
    asm "xor rdx, rdx"                % clear RDX for the division
    asm "div rbx"                     % divide RAX by 10; RAX = quotient, RDX = remainder
    asm "push rdx"                    % push the remainder (next digit) onto the stack
    asm "inc rbp"                     % increment the digit counter
    asm "mov rdi, rax"                % update RDI with the quotient
    asm "cmp rdi, 0"                  % check if the quotient is 0
    asm "je .convert_loop_end"        % if 0, end conversion
    asm "jmp .convert_loop"           % repeat for the next digit
    asm ".convert_loop_end:"          % end of the conversion loop
    asm ".print_loop:"                % start of the printing loop
    asm "pop rdi"                     % pop the next digit from the stack
    asm "add rdi, '0'"                % convert the digit to ASCII
    asm "call printc"                 % call printc to print the character
    asm "dec rbp"                     % decrement the digit counter
    asm "test rbp, rbp"               % check if there are more digits
    asm "jz .print_end"               % if 0, end printing
    asm "jmp .print_loop"             % repeat for the next digit
    asm ".print_end:"                  % end of the printing loop
}

~
readc function
args:
    none
usage example:
    readc() % first character in stdin
returns:
    the ASCII character value of the inputted character
~
fn readc() : char {
    @stackszinc 8                     % increase stack size (used for the compiler)
    asm "sub rsp, 8"                  % allocate space on the stack
    asm "mov rdi, rsp"                % set RDI to point to the stack space
    asm "mov rax, 0"                  % syscall id for read
    asm "mov rdi, 0"                  % file descriptor (STDIN)
    asm "mov rsi, rsp"                % set RSI to point to the buffer (stack space)
    asm "mov rdx, 1"                  % number of bytes to read (1)
    asm "syscall"                     % invoke the syscall to read the character
    asm "movzx rax, byte [rsp]"       % move the read character from the stack to RAX
}

~
iseq function (redundant, use `==` operator instead)
args:
    first comparison value  (stored in rdi)
    second comparison value (stored in rsi)
usage example:
    iseq(1, 1) % 1
returns:
    1 if the values are equal,
    0 if not
~
fn iseq(a : int64, b : int64) : bool {
    cmp a, b {
        eq {
            return 1
        }
    }
    return 0
}

~
readln function
args:
   the buffer (char array)
   the length of the buffer (integer)
usage example:
    reads(buffer, 512) % reads a line from stdin to buffer (max 512 bytes)
returns:
    none
~
fn readln(buffer : ptr8, buflen : int64) : void {
    let c       : char = '\0'
    buffer[buflen - 1] = '\0'
    for i = 0 -> buflen - 2 ^ 1 {
        c = readc()
        buffer[i] = c
        if c == 10 {
            buffer[i] = 0
            break
        }
    }
}

~
strlen function
args:
    the string (char array)
usage example:
    strlen("Hello") % 5
returns:
    the length of the string
~
fn strlen(str : ptr8) : int64 {
    let result : int64 = 0
    loop {
        if str[result] == '\0' break
        result = result + 1
    }
    return result
}

~
streq function
args:
    the first string  (char array)
    the second string (char array)
usage example:
    streq("Hello", "Hello") % 1
returns:
    a boolean representing if strings are equal or not
~
fn streq(str1 : ptr8, str2 : ptr8) : bool {
    let idx : int64 = 0
    let a   : char = '\0'
    let b   : char = '\0'
    loop {
        a = str1[idx]
        b = str2[idx]
        if a != b return 0
        if a == '\0' return 1
        idx = idx + 1
    }
}

~
stoi function
args:
    integer stored as string (char array)
usage example:
    stoi("1234") + 1 % 1235
returns:
    number converted to integer
~
fn stoi(str : ptr8) : int64 {
    % str = 123
    % len = 3
    let len  : int64 = strlen(str)
    let chidx : int64 = 0
    let curl  : byte  = 0
    % base10 = 100
    let base10 : int64 = pow(10, len - 1)
    let result : int64 = 0

    loop {
        curl = str[chidx] - '0'
        result = result + base10 * curl
        if base10 == 1 break
        base10 = base10 / 10
        chidx = chidx + 1
    }

    return result
}

~
pow function
args:
    base
    exponent
usage example
    pow(10, 3) % 1000
returns:
    base to the power of exp (base ^ exp)
~
fn pow(base : int64, exp : int64) : int64 {
    if exp < 0 return 0
    let result : int64 = 1
    for i = 0 -> exp - 1 ^ 1 {
        result = result * base
    }
    return result
}